<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/png" href="https://github.com/cygnus-the-series/cygnus-site/blob/main/favicon.png?raw=true">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYGNUS | Orbital Physics</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;300;400&display=swap');
        :root { --bg: #050505; --txt: #f0f0f0; --gold: #c5a059; --dim: #444; }
        body, html { margin: 0; padding: 0; background-color: var(--bg); color: var(--txt); font-family: 'Inter', sans-serif; overflow: hidden; }
        .nav-bar { display: flex; justify-content: center; padding: 30px 0; gap: 40px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); position: absolute; top: 0; width: 100%; z-index: 100; background: rgba(5, 5, 5, 0.6); backdrop-filter: blur(15px); }
        .nav-bar a { color: var(--txt); text-decoration: none; font-size: 0.7rem; letter-spacing: 0.3rem; font-weight: 300; text-transform: uppercase; transition: 0.3s; }
        .nav-bar a:hover { color: var(--gold); }
        #ui { position: absolute; bottom: 40px; left: 40px; color: var(--dim); pointer-events: none; font-family: monospace; font-size: 0.7rem; z-index: 10; line-height: 1.6; }
        #ui span { color: var(--gold); display: block; margin-bottom: 5px; }
    </style>
</head>
<body>
    <nav class="nav-bar">
        <a href="./">Home</a>
        <a href="archive">Archive</a>
        <a href="briefing">Briefing</a>
        <a href="physics">Physics</a>
        <a href="contact">Contact</a>
    </nav>
    <div id="ui"><span>DATA_STREAM // 772-B</span>STATUS: STEADY_STATE_ORBIT<br>JET_EMISSION: BIPOLAR_RELATIVISTIC</div>
    
    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let sc, cam, re, co, pa, st, je, pBH, sBH, sDi, wPa;
        const rad = 180;
        const P_C = 70000;
        const W_C = 25000;

        init();
        animate();

        function init() {
            sc = new THREE.Scene();
            cam = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 3000);
            cam.position.set(0, 180, 440); cam.lookAt(0,0,0);

            re = new THREE.WebGLRenderer({ antialias: true });
            re.setPixelRatio(window.devicePixelRatio);
            re.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(re.domElement);

            co = new EffectComposer(re);
            co.addPass(new RenderPass(sc, cam));
            const bl = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.6, 0.4, 0.85);
            bl.threshold = 0.05; bl.strength = 1.6;
            co.addPass(bl);

            const starG = new THREE.BufferGeometry();
            const starP = [];
            for (let i = 0; i < 5000; i++) starP.push((Math.random()-0.5)*2500, (Math.random()-0.5)*2500, (Math.random()-0.5)*2500);
            starG.setAttribute('position', new THREE.Float32BufferAttribute(starP, 3));
            st = new THREE.Points(starG, new THREE.PointsMaterial({color: 0x333333, size: 0.8}));
            sc.add(st);

            const jetG = new THREE.BufferGeometry();
            const jetP = new Float32Array(9000 * 3);
            for (let i = 0; i < 9000; i++) {
                const dir = i % 2 === 0 ? 1 : -1;
                jetP[i*3] = 0; jetP[i*3+1] = dir * Math.random() * 850; jetP[i*3+2] = 0;
            }
            jetG.setAttribute('position', new THREE.BufferAttribute(jetP, 3));
            je = new THREE.Points(jetG, new THREE.PointsMaterial({color: 0x00d9ff, size: 1.1, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending}));
            sc.add(je);

            const wG = new THREE.BufferGeometry();
            const wP = new Float32Array(W_C * 3);
            for (let i = 0; i < W_C; i++) {
                const r = Math.random()*340+70, t = Math.random()*Math.PI*2;
                wP[i*3] = Math.cos(t)*r; wP[i*3+1] = (Math.random()-0.5)*5; wP[i*3+2] = Math.sin(t)*r;
            }
            wG.setAttribute('position', new THREE.BufferAttribute(wP, 3));
            wPa = new THREE.Points(wG, new THREE.PointsMaterial({color: 0xffffff, size: 1.0, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending}));
            sc.add(wPa);

            const dG = new THREE.BufferGeometry();
            const dP = new Float32Array(P_C * 3), dC = new Float32Array(P_C * 3);
            for (let i = 0; i < P_C; i++) {
                const r = Math.random()*340+70, t = Math.random()*Math.PI*2;
                dP[i*3] = Math.cos(t)*r; dP[i*3+1] = (Math.random()-0.5)*6; dP[i*3+2] = Math.sin(t)*r;
                const c = new THREE.Color();
                const nR = (r - 70) / 340, n = Math.random() * 0.45;
                if (nR + n < 0.4) { c.setHSL(0.08, 0.6, 0.2 + (Math.random() * 0.1)); }
                else if (nR + n < 0.75) { c.set('#c5a059'); c.offsetHSL(0, 0, (Math.random()-0.5)*0.2); }
                else { c.setHSL(0.1, 0.4, 0.5 + (Math.random() * 0.15)); }
                dC[i*3]=c.r; dC[i*3+1]=c.g; dC[i*3+2]=c.b;
            }
            dG.setAttribute('position', new THREE.BufferAttribute(dP, 3));
            dG.setAttribute('color', new THREE.BufferAttribute(dC, 3));
            pa = new THREE.Points(dG, new THREE.PointsMaterial({size: 1.1, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending}));
            sc.add(pa);

            const bhM = new THREE.MeshBasicMaterial({color: 0x000000});
            pBH = new THREE.Mesh(new THREE.SphereGeometry(38, 32, 32), bhM);
            sc.add(pBH);
            sBH = new THREE.Mesh(new THREE.SphereGeometry(12, 32, 32), bhM);
            sc.add(sBH);

            sDi = new THREE.Mesh(new THREE.TorusGeometry(22, 5, 2, 50), new THREE.MeshBasicMaterial({color: 0xff8800}));
            sDi.rotation.x = Math.PI / 2;
            sc.add(sDi);

            for (let i = 0; i < 1500; i++) up(i * 0.016);
            window.addEventListener('resize', onResize);
        }

        function onResize() {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix();
            re.setSize(window.innerWidth, window.innerHeight);
            co.setSize(window.innerWidth, window.innerHeight);
        }

        function up(t) {
            const sx = Math.cos(t * 0.4) * rad, sz = Math.sin(t * 0.4) * rad;
            sBH.position.set(sx, 0, sz); sDi.position.set(sx, 0, sz);
            const da = pa.geometry.attributes.position.array;
            const wa = wPa.geometry.attributes.position.array;
            for (let i = 0; i < P_C; i++) {
                const dx = da[i*3] - sx, dz = da[i*3+2] - sz;
                if (dx*dx + dz*dz < 2200) { da[i*3] += dx * 0.05; da[i*3+2] += dz * 0.05; }
            }
            for (let i = 0; i < W_C; i++) {
                const dx = wa[i*3] - sx, dz = wa[i*3+2] - sz;
                if (dx*dx + dz*dz < 2200) { wa[i*3] += dx * 0.05; wa[i*3+2] += dz * 0.05; }
            }
            pa.geometry.attributes.position.needsUpdate = true;
            wPa.geometry.attributes.position.needsUpdate = true;

            const ja = je.geometry.attributes.position.array;
            for (let i = 0; i < 9000; i++) {
                const dir = i % 2 == 0 ? 1 : -1;
                ja[i*3+1] += dir * 8;
                if (dir == 1 && ja[i*3+1] > 800) ja[i*3+1] = Math.random() * 5;
                if (dir == -1 && ja[i*3+1] < -800) ja[i*3+1] = -Math.random() * 5;
                const h = ja[i*3+1], tw = h * 0.06, r = 4 + (Math.abs(h) * 0.015);
                ja[i*3] = Math.cos(tw + i) * r; ja[i*3+2] = Math.sin(tw + i) * r;
            }
            je.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            up(Date.now() * 0.001);
            pa.rotation.y += 0.0006; wPa.rotation.y += 0.0008;
            co.render();
        }
    </script>
</body>
</html>
